\documentclass[a4paper,10pt]{article}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage[english]{babel}
\usepackage{hyperref}
\hypersetup{
   colorlinks=true,
   linkcolor=blue,
   urlcolor=cyan
}
\usepackage{tikz}
\usetikzlibrary{shapes,fit,patterns}
\usepackage{amssymb}
\usepackage{pifont}
\usepackage{breqn}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{minted}
\setminted{
   numberblanklines=false, 
   mathescape, 
   texcomments, 
   autogobble, 
   breakanywhere, 
   breakautoindent, 
   breaklines,
   frame=none
}
\setminted[python]{python3}
\usepackage[
   backend=biber,%
   bibencoding=utf8,%
   language=english,%
   style=numeric-comp,%
   sorting=nyt,%
   maxbibnames=10,%
   natbib=true%
]{biblatex}
\addbibresource{references.bib}
\graphicspath{ {./img/} }

% Add X and check marks
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%

% Add subsubsubsection
\titleclass{\subsubsubsection}{straight}[\subsubsection]

\newcounter{subsubsubsection}[subsubsection]
\renewcommand\thesubsubsubsection{\thesubsubsection.\arabic{subsubsubsection}}
\renewcommand\theparagraph{\thesubsubsubsection.\arabic{paragraph}} % optional; useful if paragraphs are to be numbered

\titleformat{\subsubsubsection}
  {\normalfont\normalsize\bfseries}{\thesubsubsubsection}{1em}{}
\titlespacing*{\subsubsubsection}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{5}{\z@}%
  {3.25ex \@plus1ex \@minus.2ex}%
  {-1em}%
  {\normalfont\normalsize\bfseries}}
\renewcommand\subparagraph{\@startsection{subparagraph}{6}{\parindent}%
  {3.25ex \@plus1ex \@minus .2ex}%
  {-1em}%
  {\normalfont\normalsize\bfseries}}
\def\toclevel@subsubsubsection{4}
\def\toclevel@paragraph{5}
\def\toclevel@paragraph{6}
\def\l@subsubsubsection{\@dottedtocline{4}{7em}{4em}}
\def\l@paragraph{\@dottedtocline{5}{10em}{5em}}
\def\l@subparagraph{\@dottedtocline{6}{14em}{6em}}
\makeatother

% Set TOC depth and sections numbering
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}

% Fix tikz patterns
\pgfdeclarepatternformonly{south west lines}{\pgfqpoint{-0pt}{-0pt}}{\pgfqpoint{3pt}{3pt}}{\pgfqpoint{3pt}{3pt}}{
   \pgfsetlinewidth{0.4pt}
   \pgfpathmoveto{\pgfqpoint{0pt}{0pt}}
   \pgfpathlineto{\pgfqpoint{3pt}{3pt}}
   \pgfpathmoveto{\pgfqpoint{2.8pt}{-.2pt}}
   \pgfpathlineto{\pgfqpoint{3.2pt}{.2pt}}
   \pgfpathmoveto{\pgfqpoint{-.2pt}{2.8pt}}
   \pgfpathlineto{\pgfqpoint{.2pt}{3.2pt}}
   \pgfusepath{stroke}}
\pgfdeclarepatternformonly{south east lines}{\pgfqpoint{-0pt}{-0pt}}{\pgfqpoint{3pt}{3pt}}{\pgfqpoint{3pt}{3pt}}{
   \pgfsetlinewidth{0.4pt}
   \pgfpathmoveto{\pgfqpoint{0pt}{3pt}}
   \pgfpathlineto{\pgfqpoint{3pt}{0pt}}
   \pgfpathmoveto{\pgfqpoint{.2pt}{-.2pt}}
   \pgfpathlineto{\pgfqpoint{-.2pt}{.2pt}}
   \pgfpathmoveto{\pgfqpoint{3.2pt}{2.8pt}}
   \pgfpathlineto{\pgfqpoint{2.8pt}{3.2pt}}
   \pgfusepath{stroke}}

% Theorems
\newtheorem{theorem}{Observation}

\begin{document}
% First page
\title{Present Wrapping Problem}
\author{Leonardo Calbi (\href{mailto:leonardo.calbi@studio.unibo.it}{leonardo.calbi@studio.unibo.it}) \\ Alessio Falai (\href{mailto:alessio.falai@studio.unibo.it}{alessio.falai@studio.unibo.it})}
\date{\today}
\maketitle
\tableofcontents
\newpage
\listoffigures
\newpage

\section*{Foreword}
The problem is presented as: given a wrapping paper roll of a certain dimension and a list of presents, decide how to cut off pieces of paper so  that all the presents can be wrapped.
Consider that each present is described by the dimensions of the piece of paper needed to wrap it. Moreover, each necessary piece of paper cannot be rotated when cutting off, to respect the direction of the patterns in the paper.

A more general case also requires the following conditions:
\begin{itemize}
   \item Rotation of the pieces of paper is allowed
   \item There can be multiple presents of the same dimensions
\end{itemize}

\section{Introduction}
The non-overlapment requirement of \textit{PWP} (\textit{Present Wrapping Problem}) links it to a specialization of the more general rectangle packing problem, in which we have a set of rectangles (our presents) of given dimensions that have to fit into a pre-determined square (the wrapping paper) of a given size.

Solutions to the problem have to be tested against a set of instances, varying from $8\times 8$ to $40\times 40$ bounding boxes, with up to $29$ presents.

Observing the assigned problem instances, we assume that the items will perfectly fit into the given container, without any kind of wasted space. This assumption greatly simplifies the problem, by reducing it from a minimization to a satisfiability one.

The following sections describe our implementation of different \textit{PWP} solutions, using both Constraint Programming and Satisfiability Modulo Theory approaches.

\section{Data}
\subsection{Input}
Each instance of the problem is defined by:
\begin{itemize}
   \item \texttt{n} $\longleftarrow$ number of presents to be wrapped
   \item \texttt{w\_paper} or \texttt{w} $\longleftarrow$ width of the paper roll
   \item \texttt{h\_paper} or \texttt{h} $\longleftarrow$ height of the paper roll
   \item \texttt{presents} or \texttt{p} $\longleftarrow$ list of presents dimensions, in the form $[width,height]$
\end{itemize}

To better represent equations in the following sections, \texttt{presents} is divided in two additional lists, i.e. \texttt{presents\_xs} or \texttt{px} and \texttt{presents\_ys} or \texttt{py}.

\subsection{Output}
Outputs are presented in two different forms: a textual one and a graphical one. 

About the textual one, an output file has the following format:

\begin{Verbatim}[samepage=true]
   W H
   N
   P1X P1Y  C1X C1Y
   ...
   PNX PNY  CNX CNY
\end{Verbatim}

Here, \texttt{Pij} means present $i$, coordinate $j$; \texttt{Cij} means coordinate $j$ of the bottom-left corner of present $i$, while \texttt{W} and \texttt{H} are the paper's dimensions.

An example of a graphical solution is presented in figure \ref{fig:output}.

\begin{figure}[H]
   \centering
   \includegraphics[scale=0.8]{output.png}
   \caption{Output example}
   \label{fig:output}
\end{figure}

\newpage

\section{Constraint Programming} \label{sec:cp}
CP models are implemented with the MiniZinc language and models execution is managed by the official MiniZinc Jupyter extension, called iMiniZinc.

Following standard CP model guidelines we proceded by searching for global constraints, since they enable stronger propagation w.r.t user-defined ones; implied constraints, to allow a reduction of the search tree by pruning; channeling constraints, which can be used to gain a different point of view over the problem; symmetry-breaking constraints, that remove symmetric non-solutions from being analyzed.

In our case-study we tried different approaches, by developing different models. Some of them tend to be faster in a specific subset of instances, w.r.t. the others. In the final model, we tried to put together the different key-points of each model.

In the following subsections each and every tested constraint, along with associated decision variables, will be carefully explained.

\subsection{Decision variables} \label{sec:cp-variables}
\subsubsection*{Bottom-left corners} \label{sec:bottom-left-corners}
This is a two-dimensional list of decision variables (\texttt{bl\_corners} or \texttt{b}), where each entry represents the bottom-left corner of a rectangle in the bounding box. Finding a satisfying assignment for this list is the main goal of this project. Moreover, the list is also used to graphically represent every instance solution.

To ease its usage two additional lists were defined (\texttt{bl\_corners\_xs} or \texttt{bx} and \texttt{bl\_corners\_ys} or \texttt{by}), by channeling over each dimension of the original list.

To reduce the search space, bottom-left corners variables domains are defined as follows:
\begin{itemize}
   \item \texttt{bl\_corners}: $0 \dots \max({h, w}) - \min({\min({px}), \min({py})})$
   \item \texttt{bl\_corners\_xs}: $0 \dots w - \min({px})$
   \item \texttt{bl\_corners\_ys}: $0 \dots h - \min({py})$
\end{itemize}

\begin{figure}[H]
   \centering
   \begin{tikzpicture}
      \draw[step=1cm,black,thin] (0,0) rectangle (3,3);
      \foreach \xtick in {0,...,3} {\pgfmathsetmacro\result{\xtick * 1} \node at (\xtick,-0.5) {\pgfmathprintnumber{\result}}; }
      \foreach \ytick in {0,...,3} {\pgfmathsetmacro\result{\ytick * 1} \node at (-.5,\ytick) {\pgfmathprintnumber{\result}}; }
      \draw[fill=cyan] (2,1) rectangle (3,3);
      \draw [fill=black, thin] (2,1) circle [radius=0.05] node[below left,color=red]{(2,1)};
   \end{tikzpicture}
   \caption{Bottom-left corner example}
\end{figure}

\subsubsection*{Top-right corners} \label{sec:top-right-corners}
This is a two-dimensional list of decision variables representing the top-right corner of each rectangle (\texttt{tr\_corners} or \texttt{t}). It is used to reduce the number of positions in which a rectangle can fall in, because it must be inside the bounding box.

To ease their representation inside this paper, we refer to \texttt{tl\_corners\_xs} or \texttt{tx} as the first dimension of \texttt{tr\_corners}, while \texttt{tr\_corners\_ys} or \texttt{ty} will be used as a shorthand for the second dimension of \texttt{tr\_corners}.

To reduce the search space, \texttt{tr\_corners} variables domain is defined as follows: $$\min({\min({px}), \min({py})}) \dots \max({h, w})$$

\begin{figure}[H]
   \centering
   \begin{tikzpicture}
      \draw[step=1cm,black,thin] (0,0) rectangle (3,3);
      \foreach \xtick in {0,...,3} {\pgfmathsetmacro\result{\xtick * 1} \node at (\xtick,-0.5) {\pgfmathprintnumber{\result}}; }
      \foreach \ytick in {0,...,3} {\pgfmathsetmacro\result{\ytick * 1} \node at (-.5,\ytick) {\pgfmathprintnumber{\result}}; }
      \draw[fill=cyan] (0,0) rectangle (2,1);
      \draw [fill=black, thin] (2,1) circle [radius=0.05] node[above right,color=red]{(2,1)};
   \end{tikzpicture}
   \caption{Top-right corner example}
\end{figure}

\subsubsection*{Bottom-left corners values} \label{sec:bottom-left-corners-values}
This is a list of decision variables representing a linearization of bottom-left corners (\texttt{bl\_corners\_values}), which uses a one-to-one mapping from each two-dimensional coordinate in the bounding box to an integer value.

The mapping operates as follows:
$$ c: (x,y) \mapsto x+(y\cdot m),$$ where $m = \max{(h,w)} + 1$.

To reduce the search space, \texttt{bl\_corners\_values} variables domain is defined as follows: $$0 \dots c(w, h)$$

\begin{figure}[H]
   \centering
   \begin{tikzpicture}
      \draw[step=1cm,black,thin] (0,0) grid (3,3);
      \foreach \xtick in {0,...,3} {\pgfmathsetmacro\result{\xtick * 1} \node at (\xtick,-0.5) {\pgfmathprintnumber{\result}}; }
      \foreach \ytick in {0,...,3} {\pgfmathsetmacro\result{\ytick * 1} \node at (-.5,\ytick) {\pgfmathprintnumber{\result}}; }
      \foreach \x in {0,...,3} {\foreach \y in {0,...,3} {\draw [fill=black, thin] (\x,\y) circle [radius=0.05] node[above right,color=red] {\pgfmathparse{\x+\y*4} \pgfmathprintnumber{\pgfmathresult}};}}
   \end{tikzpicture}
   \caption{Example of 2D-coordinates linearization in a 3 by 3 box}
\end{figure}

\subsection{Constraints} \label{sec:cp-constraints}
The constraints described below, divided by scope, are presented at the top of each section with a simple schema depicting their evolution throughout different models.
The following is a legend explaining how constraints advancement is achieved:
\begin{itemize}
   \item \texttt{A[x]}: Constraint \texttt{A} has been introduced in model number \texttt{x}
   \item \texttt{A[x]} $\rightarrow$ \texttt{B[y]}: Constraint \texttt{A} was removed in favor of \texttt{B}, in model \texttt{y}
   \item \texttt{A[x]} $\rightarrow$ \xmark: Constraint \texttt{A} has not been carried over to models \texttt{x + 1, \dots}
\end{itemize}
Model numbers are related to their organization inside the attached Jupyter notebook.

\subsubsection{Non-overlapment}
\begin{itemize}
   \item \nameref{sec:presents-cannot-overlap} $\rightarrow$ \nameref{sec:diffnk}
   \item \nameref{sec:different-bl-corners}
\end{itemize}

\subsubsubsection{Presents cannot overlap [1]} \label{sec:presents-cannot-overlap}
The idea behind this simple constraint is, given a rectangle, to avoid the existance of areas of overlap with every other rectangle.
\begin{gather*}
   \max({bx_{i}, bx_{j}}) \geq \min({bx_{i} + px_{i}, bx_{j} + px_{j}}) \\
   \vee \\
   \max({by_{i}, by_{j}}) \geq \min({by_{i} + py_{i}, by_{j} + py_{j}}) \\
   \forall{i, j = 1 \dots n \mid j > i}
\end{gather*}

The described constraint has been observed to be efficient enough for relatively small instances of the problem, while already suffering to position rectangles in a $17 \times 17$ bounding box. Results are justified by the disjunctive nature of the constraint, which implies an higher burden in the propagation phase.

\subsubsubsection{Global \texttt{diffn\_k} [3]} \label{sec:diffnk}
The \texttt{diffn\_k} global constraint is defined by the official MiniZinc documentation \cite{minizinc} as follows: \\
\emph{Constrains k-dimensional boxes to be non-overlapping. For each box i and dimension j, box\_posn[i, j] is the base position of the box in dimension j, and box\_size[i, j] is the size in that dimension. Boxes whose size is 0 in any dimension still cannot overlap with any other box.}
\begin{Verbatim}[samepage=true]
   constraint diffn_k(bl_corners, presents);
\end{Verbatim}
Being a global constraint, it gives a stronger propagation and a more efficient search w.r.t to \nameref{sec:presents-cannot-overlap}, allowing us to solve bigger instances, up to a $23 \times 23$ bounding box.

It's also notable, as described by \cite{sweep}, that \texttt{diffn\_k} is an onerous constraint. In \cite{sweep} it accounts for 30 to 80\% of the total running time, in an implementation of the \emph{PSP (Perfect Square Packing)} problem, which is very much related to \emph{PWP}.

\subsubsubsection{Global \texttt{all\_different} [2]} \label{sec:different-bl-corners}
The \texttt{all\_different} global constraint asserts that every variable has a different value assigned to it.

In our models it is used w.r.t \texttt{bl\_corners\_values} to ensure that every present has different \texttt{bl\_corners}. The choice of the constrained variables is related to their one-dimensional nature, which guarantees compatibility with MiniZinc's implementation of \texttt{all\_different}.
\begin{Verbatim}[samepage=true]
   constraint alldifferent(bl_corners_values);
\end{Verbatim}

\subsubsection{Containment}
\begin{itemize}
   \item \nameref{sec:reduce-presents-domains}
   \item \nameref{sec:areas-summation}
\end{itemize}

\subsubsubsection{Reduce presents domains [1]} \label{sec:reduce-presents-domains}
The original description is the following one, where the lenght $l$ corresponds to the height \texttt{h\_paper} of the bounding box.:\\
\emph{In any solution, if we draw a vertical line and sum the vertical sides of the traversed pieces, the sum can be at most l. A similar property holds if we draw a horizontal line.}

As suggested by the assignment, we implemented this simple implied constraint which avoids pieces overflow in both directions.
\begin{gather*}
   bx_{i} \leq w - px_{i} \wedge by_{i} \leq h - py_{i}, \forall{i = 1 \dots n}
\end{gather*}

\subsubsubsection{Areas summation [4]} \label{sec:areas-summation}
This implied constraint is used to enforce presents to occupy the entire bounding box, without any kind of wasted space.
In particular, presents areas computed by using top-right and bottom-left corners are linked to the areas calculated using input pieces dimensions.

\begin{gather*}
   \sum_{i=1}^{n} (tx_{i} - bx_{i}) \cdot (ty_{i} - by_{i}) \leq w \cdot h
\end{gather*}
\begin{gather*}
   \sum_{i=1}^{n} (tx_{i} - bx_{i}) \cdot (ty_{i} - by_{i}) = \sum_{i=1}^{n} (px_{i} \cdot py_{i})
\end{gather*}

\subsubsection{Positioning}
\begin{itemize}
   \item \nameref{sec:present-at-origin}
   \item \nameref{sec:intervals-approach} $\rightarrow$ \xmark
   \item \nameref{sec:anchor-points-v1} $\rightarrow$ \nameref{sec:anchor-points-v2}$\rightarrow$ \xmark
\end{itemize}

\subsubsubsection{Global \texttt{count\_eq} [2]} \label{sec:present-at-origin}
This implied constraint exploits again the usage of bottom-left corners linearization, i.e. \texttt{bl\_corners\_values},
by stating that one and only one present should be placed with its bottom-left corner at the origin.

\begin{gather*}
   \lvert\{\,i \mid bx_{i} = 0 \wedge by_{i} = 0\,\}\rvert = 1
\end{gather*}

As mentioned in the section title, this idea has been implemented using the \texttt{count\_eq} global constraint.

\begin{Verbatim}[samepage=true]
   constraint count_eq(bl_corners_values, 0, 1);
\end{Verbatim}

\subsubsubsection{Intervals approach [5]} \label{sec:intervals-approach}
It represents an idea taken from \cite{rect-packing}, where domains associated with the $x$-coordinate of bottom-left corners are reduced on the basis of a variable-sized interval:\\
\emph{[...] a rectangle is assigned an interval of x-coordinates. Interval sizes are hand-picked for each rectangle prior to search, and they induce a smaller rectangle representing the common intersecting area of placing the rectangle in any location in the interval. [...] we assign all x-coordinates prior to any y-coordinates, and use interval variables for the x-coordinates. We set a rectangleâ€™s interval size to 0.35 times its width, which gave us the best performance. Finally, we do not use interval variables for the y-coordinates.}

\begin{figure}[H]
   \centering
   \begin{tikzpicture}
      \draw[step=1cm,black,thin] (0,0) grid (6,2);
      \foreach \xtick in {0,...,6} {\pgfmathsetmacro\result{\xtick * 1} \node at (\xtick,-0.5) {\pgfmathprintnumber{\result}}; }
      \draw[fill=green, thick] (0,0) circle [radius=0.05];
      \draw[fill=green, thick] (1,0) circle [radius=0.05];
      \draw[fill=green, thick] (2,0) circle [radius=0.05];
      \draw[color=green, thick] (0,0) -- (2,0);
      \draw[pattern=dots, pattern color=black] (2,0) rectangle (4,2);
      \draw[pattern=south west lines, pattern color=red] (4,0) rectangle (6,2);
   \end{tikzpicture}
   \caption{Intervals example: assigning $[0,2]$ to a $4\times2$ rectangle}
   \label{fig:intervals}
\end{figure}

As shown in figure \ref{fig:intervals}, a $4\times2$ rectangle assigned an $x$-interval of $[0,2]$ in a $6\times2$ box always consumes the units of area represented by the dotted rectangle,
while the rectangle containing red lines heading south west only has the possibility, and not the certainty, of being partially or totally consumed.
Moreover, the points on the green line represent the feasible assignments to the $x$-coordinate of the $4\times2$ rectangle's bottom-left corner.

In a more general situation, where the rectangle's height is less than the bounding box height, the $x$-interval reasoning remains the same, while the number of feasibile assignments to bottom-left corner's $y$-coordinate increases.

As a side note, the chosen interval in figure \ref{fig:intervals} has a size of $2$ because
$$ \lceil 4 \cdot 0.35 \rceil = \lceil 1.4 \rceil = 2,$$
where $4$ is the rectangle's width and $0.35$ is the selected parameter to compute interval sizes.

If there were no feasible set of interval assignments, then the constraint would save us from having to try individual $x$ values. However, if we do find a set of interval assignments, then we must search for a set of single $x$-coordinate values.

In the end, the implementation of this constraint didn't provide significant improvements. Hence, it is not present in the final CP model.

\subsubsubsection{Anchor points [5]} \label{sec:anchor-points-v1}
It represents a reduction on each present's domain, such that bottom-left corners reside on corners of other rectangles or on the wrapping paper borders.

The main implementation-wise problem was our inability of correctly expressing the constraint in an efficient way: the only thing we were able to describe is an upper bound on the number of the overall distinct corners that can be found inside the bounding box at the same time, while also satisfying every other constraint.
To do that, a new list of decision variables had to be created (\texttt{corners\_values}), containing the linearization (as in \ref{sec:bottom-left-corners-values}) of every corner for each present.
The constraint was then posted by limiting unique values, i.e. unique corners, over this new list of variables. Then, each bounding box corner was forced to coincide with exactly one value inside \texttt{corners\_values}.

\begin{Verbatim}[samepage=true]
   constraint nvalue(corners_values) <= 2 * n + 2
\end{Verbatim}

The reported upper bound has been computed as follows:
\begin{theorem}
   Let $n$ be the number of rectangles to be placed inside a given squared bounding box.
   Let's assume that rectangles will completely fit inside the container, without free space.
   Then, we have that the number of distinct rectangles corners $k$ should be less than or equal to $2\cdot n + 2$.
\end{theorem}
\begin{proof}[Reasoning]
   Since we have $n$ rectangles, the total number of corners is exactly $4 \cdot n$. Moreover, we know that $4$ of these corners are reserved by the bounding box ones.
   For at least half of the other corners ($\frac{4 \cdot n - 4}{2}$), each one must be shared with at least two rectangles, because of our no-free-space assumption.
   By following this reasoning, we obtain these results:
   $$
      k \leq \frac{4 \cdot n - 4}{2} + 4 = 2\cdot n + 2 = u
   $$
\end{proof}

\begin{figure}[H]
   \centering
   \begin{subfigure}[H]{.4\textwidth}
      \centering
      \begin{tikzpicture}
         \draw[step=1cm,black,thin] (0,0) rectangle (3,3);
         \foreach \xtick in {0,...,3} {\pgfmathsetmacro\result{\xtick * 1} \node at (\xtick,-0.5) {\pgfmathprintnumber{\result}}; }
         \foreach \ytick in {0,...,3} {\pgfmathsetmacro\result{\ytick * 1} \node at (-.5,\ytick) {\pgfmathprintnumber{\result}}; }
         \draw[fill=cyan] (0,0) rectangle (2,1);
         \draw[fill=magenta] (0,1) rectangle (2,3);
         \draw[fill=green] (2,1) rectangle (3,3);
         \draw[fill=yellow] (2,0) rectangle (3,1);
         \draw [fill=black, thin] (0,0) circle [radius=0.05];
         \draw [fill=black, thin] (2,0) circle [radius=0.05];
         \draw [fill=black, thin] (3,0) circle [radius=0.05];
         \draw [fill=black, thin] (0,1) circle [radius=0.05];
         \draw [fill=black, thin] (2,1) circle [radius=0.05];
         \draw [fill=black, thin] (3,1) circle [radius=0.05];
         \draw [fill=black, thin] (0,3) circle [radius=0.05];
         \draw [fill=black, thin] (2,3) circle [radius=0.05];
         \draw [fill=black, thin] (3,3) circle [radius=0.05];
      \end{tikzpicture}
      \caption{$k=9 \leq 10 =u$}
   \end{subfigure}
   \begin{subfigure}[H]{.4\textwidth}
      \centering
      \begin{tikzpicture}
         \draw[step=1cm,black,thin] (0,0) rectangle (3,3);
         \foreach \xtick in {0,...,3} {\pgfmathsetmacro\result{\xtick * 1} \node at (\xtick,-0.5) {\pgfmathprintnumber{\result}}; }
         \foreach \ytick in {0,...,3} {\pgfmathsetmacro\result{\ytick * 1} \node at (-.5,\ytick) {\pgfmathprintnumber{\result}}; }
         \draw[fill=cyan] (0,0) rectangle (2,2);
         \draw[fill=magenta] (0,2) rectangle (3,3);
         \draw[fill=green] (2,1) rectangle (3,2);
         \draw[fill=yellow] (2,0) rectangle (3,1);
         \draw [fill=black, thin] (0,0) circle [radius=0.05];
         \draw [fill=black, thin] (2,0) circle [radius=0.05];
         \draw [fill=black, thin] (3,0) circle [radius=0.05];
         \draw [fill=black, thin] (2,1) circle [radius=0.05];
         \draw [fill=black, thin] (3,1) circle [radius=0.05];
         \draw [fill=black, thin] (0,2) circle [radius=0.05];
         \draw [fill=black, thin] (2,2) circle [radius=0.05];
         \draw [fill=black, thin] (3,2) circle [radius=0.05];
         \draw [fill=black, thin] (0,3) circle [radius=0.05];
         \draw [fill=black, thin] (3,3) circle [radius=0.05];
      \end{tikzpicture}
      \caption{$k=10 \leq 10 =u$}
   \end{subfigure}
   \caption{Distinct corners upper bound example}
\end{figure}

\subsubsubsection{Anchor points [6]} \label{sec:anchor-points-v2}
This constraint, taken from \cite{sweep} is an evolution of \nameref{sec:anchor-points-v1}, which introduces a more coincise and efficient anchor points approach.
This time the main idea is about causing the bottom-left corner of a single rectangle to fit a bottom-right or top-left corner of another already-placed rectangle, thus reducing the amount of available positions.

\begin{gather*}
   bx_{i} \in \{\,0\,\} \cup \{\, bx_{j} + px_{j} \mid j = 1 \dots i - 1, i + 1, \dots n \,\} \\
   \wedge \\
   by_{i} \in \{\,0\,\} \cup \{\, by_{j} + py_{j} \mid j = 1 \dots i - 1, i + 1, \dots n \,\} \\
   \forall{i = 1 \dots n}
\end{gather*}

The described formula was implemented using the global constraint \texttt{member}, so as to achieve better propagation.

The constraint was later removed from the CP model, since it didn't seem to make any major difference, at least w.r.t. running times over the test instances, even though it was implemented using the mentioned global constraint.

\begin{figure}[H]
   \centering
   \begin{tikzpicture}
      \draw[step=1cm,black,thin] (0,0) rectangle (3,3);
      \foreach \xtick in {0,...,3} {\pgfmathsetmacro\result{\xtick * 1} \node at (\xtick,-0.5) {\pgfmathprintnumber{\result}}; }
      \foreach \ytick in {0,...,3} {\pgfmathsetmacro\result{\ytick * 1} \node at (-.5,\ytick) {\pgfmathprintnumber{\result}}; }
      \draw[fill=cyan] (0,0) rectangle (2,1);
      \draw[color=red, thick] (2,0.01) rectangle (2.2,0.2);
      \draw[color=red, thick] (0,1.01) rectangle (0.2,1.2);
   \end{tikzpicture}
   \caption{Anchor points example}
   \label{fig:anchor-points}
\end{figure}

Figure \ref{fig:anchor-points} shows the available placements of a rectangle, different than the one filled in cyan,
which could be positioned in such a way that its bottom-left corner would overlap with one of the two small red rectangles.

\subsubsection{Stacking}
\begin{itemize}
   \item \nameref{sec:cumulative}
   \item \nameref{sec:stack-two} $\rightarrow$ \nameref{sec:column-stacking}
\end{itemize}

\subsubsubsection{Global \texttt{cumulative} [3]} \label{sec:cumulative}
The \texttt{cumulative} global constraint is defined by the official MiniZinc documentation \cite{minizinc} as follows: \\
\emph{Requires that a set of tasks given by start times s, durations d, and resource requirements r, never require more than a global resource bound b at any one time.}

\begin{Verbatim}[samepage=true]
   constraint cumulative(
      bl_corners_xs, presents_xs, presents_ys, h_paper
   );
   constraint cumulative(
      bl_corners_ys, presents_ys, presents_xs, w_paper
   );
\end{Verbatim}

In the context of rectangle packing, the cumulative global constraint can be used by selecting $x$-coordinates of bottom-left corners as start times, by assigning durations to presents widths, resource requirements to presents heights and the global resource bound to the paper roll height.
The same reasoning can be applied for the other dimension, in order to obtain overflow avoidance and stacking maximization over both axis.

\begin{figure}[H]
   \centering
   \includegraphics[scale=0.2]{cumulative.png}
   \caption{Cumulative global constraint (image taken from \cite{cumulative})}
   \label{fig:cumulative}
\end{figure}

Figure \ref{fig:cumulative} shows an example of the \texttt{cumulative} global constraint, along with the usage of \texttt{disjoint2}, which is the twin constraint of the already mentioned \texttt{diffn\_k}.

The combination of \texttt{cumulative} and \texttt{diffn\_k} is actually the core of the CP model, since together they enable a very strong propagation, which can be directly observed by looking at solving times.

\subsubsubsection{Column stacking by two [4]} \label{sec:stack-two}
The main idea behind this simple constraint is to stack presents in a single row or column such that their widths or heights would sum to the total width or height, respectively, of the entire paper roll.

\begin{figure}[H]
   \centering
   \begin{tikzpicture}
      \draw[step=1cm,black,thin] (0,0) rectangle (3,3);
      \foreach \xtick in {0,...,3} {\pgfmathsetmacro\result{\xtick * 1} \node at (\xtick,-0.5) {\pgfmathprintnumber{\result}}; }
      \foreach \ytick in {0,...,3} {\pgfmathsetmacro\result{\ytick * 1} \node at (-.5,\ytick) {\pgfmathprintnumber{\result}}; }
      \draw[fill=cyan] (0,0) rectangle (2,1);
      \draw[fill=cyan] (0,1) rectangle (2,3);
      \draw[fill=magenta] (2,0) rectangle (3,2);
      \draw[fill=magenta] (2,2) rectangle (3,3);
   \end{tikzpicture}
   \caption{Column stacking by two example}
   \label{fig:col-stacking-two}
\end{figure}

In figure \ref{fig:col-stacking-two}, we can observe two different groups, the cyan and the magenta one. In this example, we are stacking by columns, since each color group contains rectangles with the same width and such that their heights sum to the total bounding box height.

When the constraint is applied, both rectangles must have the same $x$-coordinate for bottom-left corners, while the $y$-coordinate is assigned to zero for the "first" rectangle and to the height of the first present for the "second" rectangle.

\subsubsubsection{General column stacking [5]} \label{sec:column-stacking}
This constraint is a generalization of the simpler \nameref{sec:stack-two}, which introduces packing multiple rectangles, i.e. groups of size greater than two, into multiple columns.

\begin{figure}[H]
   \centering
   \begin{tikzpicture}
      \draw[step=1cm,black,thin] (0,0) rectangle (5,5);
      \foreach \xtick in {0,...,5} {\pgfmathsetmacro\result{\xtick * 1} \node at (\xtick,-0.5) {\pgfmathprintnumber{\result}}; }
      \foreach \ytick in {0,...,5} {\pgfmathsetmacro\result{\ytick * 1} \node at (-.5,\ytick) {\pgfmathprintnumber{\result}}; }
      \draw[fill=cyan] (0,0) rectangle (2,1);
      \draw[fill=cyan] (0,1) rectangle (2,3);
      \draw[fill=cyan] (0,3) rectangle (2,5);
      \draw[fill=cyan] (2,0) rectangle (4,2);
      \draw[fill=cyan] (2,2) rectangle (4,5);
      \draw[fill=magenta] (4,0) rectangle (5,2);
      \draw[fill=magenta] (4,2) rectangle (5,4);
      \draw[fill=magenta] (4,4) rectangle (5,5);
   \end{tikzpicture}
   \caption{General column stacking example}
   \label{fig:col-stacking}
\end{figure}

This predicate is subdivided into different steps:
\begin{itemize}
   \item Groups identification: finds and groups together presents with the same width
   \item Feasibility check: ensures that every group can occupy at least one entire column
   \item Columns computation: calculates the number of columns (and the corresponding widths) occupied by each group (e.g. a group of width $2$ with heights $[1,2,3]$ in a $12\times3$ box will occupy exactly two columns of width $2$)
   \item Columns/coordinates assignment: using the \texttt{bin\_packing} global constraint to identify the column for each rectangle in the same group, it incrementally fixes $x$ and $y$ bottom-left corners coordinates
\end{itemize}

Groups are ordered by decreasing widths, while rectangles in the same group are sorted by decreasing heights.

In figure \ref{fig:col-stacking} we can see how the entire group of cyan-filled rectangles, which has a common width of $2$, gets splitted into subsequent columns, while the magenta-colored group can only occupy one column, the last one in this example.

\subsubsection{Symmetry breaking}
\begin{itemize}
   \item \nameref{sec:biggest-lower-left} $\rightarrow$ \nameref{sec:areas-ordering}
   \item \nameref{sec:width-ordering} $\rightarrow$ \xmark
\end{itemize}

\subsubsubsection{Biggest rectangle in lower left quadrant [4]} \label{sec:biggest-lower-left}
Inspired by the standard n-queens problem, we tried to analyze \textit{PWP} and its solutions, obtained by reflecting axes.

To cut the search space and avoid exploring paths leading to symmetric non-solutions, we decided to force the biggest rectangle, i.e. the one with greatest area, to have its bottom-left corner inside the lower-left quadrant of the bounding box.

\begin{figure}[H]
   \centering
   \begin{subfigure}[b]{0.4\textwidth}
      \centering
      \begin{tikzpicture}
         \draw[step=1cm,black,thin] (0,0) rectangle (4,4);
         \foreach \xtick in {0,...,4} {\pgfmathsetmacro\result{\xtick * 1} \node at (\xtick,-0.5) {\pgfmathprintnumber{\result}}; }
         \foreach \ytick in {0,...,4} {\pgfmathsetmacro\result{\ytick * 1} \node at (-.5,\ytick) {\pgfmathprintnumber{\result}}; }
         \draw[fill=cyan] (0,2) rectangle (2,3);
         \draw[fill=magenta] (0,0) rectangle (2,2);
         \draw[fill=green] (2,1) rectangle (3,3);
         \draw[fill=yellow] (2,0) rectangle (3,1);
         \draw[fill=red] (3,0) rectangle (4,3);
         \draw[fill=blue] (0,3) rectangle (3,4);
         \draw[fill=brown] (3,3) rectangle (4,4);
      \end{tikzpicture}
      \caption{Original solution}
      \label{fig:symmetry-a}
   \end{subfigure}
   \begin{subfigure}[b]{0.4\textwidth}
      \centering
      \begin{tikzpicture}
         \draw[step=1cm,black,thin] (0,0) rectangle (4,4);
         \foreach \xtick in {0,...,4} {\pgfmathsetmacro\result{\xtick * 1} \node at (\xtick,-0.5) {\pgfmathprintnumber{\result}}; }
         \foreach \ytick in {0,...,4} {\pgfmathsetmacro\result{\ytick * 1} \node at (-.5,\ytick) {\pgfmathprintnumber{\result}}; }
         \draw[fill=cyan] (2,1) rectangle (4,2);
         \draw[fill=magenta] (2,2) rectangle (4,4);
         \draw[fill=green] (1,1) rectangle (2,3);
         \draw[fill=yellow] (1,3) rectangle (2,4);
         \draw[fill=red] (0,1) rectangle (1,4);
         \draw[fill=blue] (1,0) rectangle (4,1);
         \draw[fill=brown] (0,0) rectangle (1,1);
      \end{tikzpicture}
      \caption{Reflected solution}
      \label{fig:symmetry-b}
   \end{subfigure}
   \caption{Symmetric solutions example}
   \label{fig:symmetry}
\end{figure}

Figure \ref{fig:symmetry} depicts an example of specular solutions, s.t. subfigure \ref{fig:symmetry-a} satisfies the constraint, while \ref{fig:symmetry-b} does not.

In the end, we realized that this approach was too limiting, thus leading to an increase in the number of failures. Because of this, we decided to remove it in favor of \nameref{sec:areas-ordering}.

\subsubsubsection{Ordering by areas [6]} \label{sec:areas-ordering}
This constraint is based on \cite{sweep} and it is used to create a lexicographical ordering between the bottom-left corners coordinates of the biggest rectangle $r_{1}$, i.e. the one with the greatest area, and the coordinates of the second biggest present $r_{2}$.
In this way, $r_{1}$ must be placed below and/or to the left of $r_{2}$.

\begin{Verbatim}[samepage=true]
   lex_less(
      [bl_corners_ys[r1], bl_corners_xs[r1]],
      [bl_corners_ys[r2], bl_corners_xs[r2]]
   );
\end{Verbatim}

Implementation-wise, we decided to use the global constraint \texttt{lex\_less}, as shown above.

\subsubsubsection{In-column ordering by width [4]} \label{sec:width-ordering}
This was our first try to enable some kind of ordering between presents with the same bottom-left corners $x$-coordinates.
In particular, those presents which happen to have the same $x$-coordinate will be constrained to be ordered by their heights s.t. smaller pieces would lie below the taller ones.

Results were not good at all, since this approach transformed a subset of solvable instances into unfeasible ones, because it was highly dependent on input presents order. Hence, the constraint is not present in the final model.

\subsection{Models}
In this section are presented our final models and their search strategy. The optional model has the ability to handle presents rotation and rectangles with the same shapes.

\subsubsection{Search strategy}
We decided to prioritize positioning "bigger" presents first, since their placement greatly reduces the domain of the other ones. After trying every meaningful ordering, i.e. by height, width or area, the one that gave us the best outcomes was sorting presents by decreasing values of area.

\begin{Verbatim}[samepage=true]
   array[1..n] of int: areas =
      [presents_xs[i] * presents_ys[i] | i in 1..n];
   array[1..n] of 1..n: order =
      sort_by(1..n, [-areas[i] | i in 1..n]);
\end{Verbatim}

The actual search strategy starts by checking if \nameref{sec:column-stacking} is feasible. In case of a positive answer we do not need to apply complex approaches, since everything is already handled by column stacking positioning. On the other hand, when column stacking is not feasible, we rely on the previously defined ordering by assigning firstly $y$-coordinates and then $x$-coordinates. These assignments are done by selecting values starting from the minimum one in each domain.

In this kind of search strategy applying restarts was not an option, since we didn't have any random component. Anyway we tried to use \texttt{luby} and \texttt{constant} restarts in a simpler search strategy, where values in each domain were selected at random, but it resulted into worse running times.

\begin{Verbatim}[samepage=true]
   solve::
    if not(col_stacking_feasible) then
        seq_search([
            int_search(
               [bl_corners_ys[i] | i in order],
               input_order,
               indomain_min,
               complete
            ),
            int_search(
               [bl_corners_xs[i] | i in order],
               input_order,
               indomain_min,
               complete
            )
        ])
    else
      int_search(
         bl_corners_values,
         dom_w_deg,
         indomain_min,
         complete
      )
    endif
   satisfy;
\end{Verbatim}

\subsubsection{Final model}
To present a global undestanding of our final CP model, below we report a list linking to each and every included constraint.
\begin{itemize}
   \item \nameref{sec:diffnk}
   \item \nameref{sec:cumulative}
   \item \nameref{sec:reduce-presents-domains}
   \item \nameref{sec:different-bl-corners}
   \item \nameref{sec:present-at-origin}
   \item \nameref{sec:areas-summation}
   \item \nameref{sec:areas-ordering}
   \item \nameref{sec:column-stacking}
\end{itemize}
Using this model we were able to solve every test instance, with the exception of the $23\times23$ one, in under one second. This was mostly possible thanks to the \nameref{sec:column-stacking} constraint, which enabled us to reduce running times, in particular w.r.t. bigger instances.

\begin{figure}[H]
   \centering
   \includegraphics[scale=0.45]{cp-times.png}
   \caption{Final CP model running times}
\end{figure}

\subsubsection{Optional model}
This model is dedicated to the implementation of the optional parts of the project, namely rotation and same dimensions handling.

About rotation, we removed the column stacking approach, since presents dimensions are now considered as variables, and we introduced the global constraint \texttt{geost\_bb} which can be used to find appropriate positions and rotations of the given rectangles without overlaps, by constraining them to be contained in a given bounding box. Since \texttt{geost\_bb} also handles non-overlapment, the \texttt{diffn\_k} constraint was removed from this model. This approach obviously turned out to be much slower w.r.t. our final model.

The \texttt{geost\_bb} global constraint is defined by the official MiniZinc documentation \cite{minizinc} as follows: \\
\emph{A global non-overlap constraint for k dimensional objects. It enforces that no two objects overlap, and that all objects fit within a global k dimensional bounding box.}

\begin{Verbatim}[samepage=true]
   constraint geost_bb(
      k, rect_size, rect_offset, shape, bl_corners, kind, l, u
   );
\end{Verbatim}

About \texttt{geost\_bb} parameters, as described in \cite{geost}:
\begin{itemize}
   \item \texttt{k}: The number of dimensions, i.e. 2
   \item \texttt{rect\_size}: The size of each rectangle in \texttt{k} dimensions, i.e. a list of $2\cdot n$ elements given by the dimensions of each present and its $90^{\circ}$ rotation
   \item \texttt{rect\_offset}: The offset of each rectangle from the base position in \texttt{k}  dimensions, i.e. a list of $2\cdot n$ elements fixed to $[0,0]$, representing the offset of each rectangle from the top-right corner of its minimum enclosing bounding-box
   \item \texttt{shape}: The set of rectangles defining the $i$-th shape, i.e.a list of $2\cdot n$ indexes going from $1$ to $2\cdot n$, representing that each figure is directly associated with exactly one rectangle
   \item \texttt{bl\_corners}: The base position of each object
   \item \texttt{kind}: A list of $n$ elements, representing the shape used by each object, i.e. either the original rectangle or its $90^{\circ}$ rotation
   \item \texttt{l}: An array of lower bounds, i.e. the bottom-left corner of our paper roll
   \item \texttt{u}: An array of upper bounds, i.e. the top-right corner of our paper roll.
\end{itemize}

In order to achieve better results, it could be possible to find the minimum number of rotations needed to make column stacking feasible and proceed like before.

About rectangles with same dimensions, we simply included a symmetry breaking constraint accounting for pairwise positioning of equally-sized presents, because these presents can be swapped without any kind of difference in the results.

\begin{Verbatim}[samepage=true]
   constraint forall(i in 1..n)(
      let {
          array[int] of int: same_dim_ind = [
               j | j in 1..n where
               presents_xs[j] = presents_xs[i] /\
               presents_ys[j] = presents_ys[i]
            ]
      } in
          if
            length(same_dim_ind) > 1 /\
            min(same_dim_ind) = i
          then
            forall(j in index_set(same_dim_ind) where j > 1) (
               lex_less(
                  [
                     bl_corners_ys[same_dim_ind[j - 1]],
                     bl_corners_xs[same_dim_ind[j - 1]]
                  ],
                  [
                     bl_corners_ys[same_dim_ind[j]],
                     bl_corners_xs[same_dim_ind[j]]
                  ]
               )
            )
          else true
          endif
  );
\end{Verbatim}

The above code groups rectangles with the same dimensions and constrains the one with the minimum index to be placed below and/or to the left of the second one; the same happens between the second and the third presents in the same group; and so on and so forth. This approach creates a chain of constraints s.t. every symmetric solution and non-solution is eliminated from the search path.

\newpage

\section{Satisfiability Modulo Theory} \label{sec:smt}
SMT models are implemented with the Z3 Python API and models execution is managed within the Jupyter notebook instance, as already described for CP models.

Since we obtained great results with the constraints described in \ref{sec:cp-constraints}, we tried to re-implement the same ideas as in the CP models above, converting code from MiniZinc to be compatible with Z3 specifications.

\subsection{Decision variables}
Variables for the SMT models are more or less the same as those described in \ref{sec:cp-variables}. So, the main ones are \texttt{bl\_corners}, but we are also keeping track of \texttt{tr\_corners}. 

In addition, we are introducing rectangles areas (\texttt{actual\_areas} or \texttt{a}) computed from bottom-left and top-right corners. 

\begin{gather*}
   a_{i} = (tx_{i} - bx_{i}) \cdot (ty_{i} - by_{i})
\end{gather*}

Moreover, we are getting rid of bottom-left corners values, i.e. \texttt{bl\_corners\_values}, since constraints associated with this list of variables seemed redundant for our SMT model.

\subsection{Formulae}
By looking at MiniZinc's standard library \cite{minizinc-lib} and other implementations of SMT functions, available online (e.g. \cite{hakank}), we tried to translate predicates into lists of formulae.

\subsubsection{Non-overlapment}
\begin{itemize}
   \item \nameref{sec:smt-diffn}
   \item \nameref{sec:smt-all-different}
\end{itemize}

\subsubsubsection{Translation of \texttt{diffn} [1]} \label{sec:smt-diffn}
The \texttt{diffn} global constraint is translated as a single CNF (Conjunctive Normal Form) formula, where each clause identifies pairwise non-overlapment checks. As show below, we can see that it resembles our implementation of the \nameref{sec:presents-cannot-overlap} CP constraint, which was the first one to be coded to avoid presents intersections.

\begin{minted}[samepage]{python}
def z3_diffn(x, y, dx, dy):
   '''
   Return a list of constraints computing non-overlapping checks
   '''
   c = []
   n = len(x)
   for i in range(n):
      for j in range(i + 1, n):
         c.append(
            And(Or([
               x[i] + dx[i] <= x[j],
               y[i] + dy[i] <= y[j],
               x[j] + dx[j] <= x[i],
               y[j] + dy[j] <= y[i]
            ]))
         )
   return c
\end{minted}

About \texttt{z3\_diffn} parameters:
\begin{itemize}
   \item \texttt{x}: \texttt{bl\_corners\_xs}
   \item \texttt{y}: \texttt{bl\_corners\_ys}
   \item \texttt{dx}: \texttt{presents\_xs}
   \item \texttt{dy}: \texttt{presents\_ys}
\end{itemize}

\subsubsubsection{Translation of \texttt{all\_different} [1]} \label{sec:smt-all-different}
The \texttt{all\_different} global constraint is translated as a single CNF formula, where each clause identifies pairwise difference checks. Our implementation is based on the assumption of receiving a two-dimensional input, with a variable number of columns, that should also be given as an additional parameter. 

\begin{minted}[samepage]{python}
def z3_alldifferent_mat(l, s):
   '''
   Return a list of constraints computing all different checks
   '''
   assert(s > 1)
   
   c = []
   n = len(l)
   for i in range(n):
      for j in range(i + 1, n):
         disjunction = []
         for k in range(s):
            disjunction.append(l[i][k] != l[j][k])
         c.append(Or(disjunction))
   return c
\end{minted}

About \texttt{z3\_alldifferent\_mat} parameters:
\begin{itemize}
   \item \texttt{l}: \texttt{bl\_corners}
   \item \texttt{s}: $2$, representing two coordinates for each corner
\end{itemize}

\subsubsection{Containment}
\begin{itemize}
   \item \nameref{sec:smt-reduce-presents-domains}
   \item \nameref{sec:smt-areas-summation}
\end{itemize}

\subsubsubsection{Reduce presents domains [1]} \label{sec:smt-reduce-presents-domains}
Since SMT does not provide a way to constrain variables' domain, we proceeded to define a list of conjunctive formulas, in order to avoid presents overflowing the bounding box. For more information, refer to \nameref{sec:reduce-presents-domains}.

\begin{gather*}
   0 \leq bx_{i} \leq w - px_{i} \wedge 0 \leq by_{i} \leq h - py_{i} \\
   px_{i} \leq tx_{i} \leq w \wedge py_{i} \leq ty_{i} \leq h \\
   \forall{i \mid i = 1 \dots n}
\end{gather*}

\subsubsubsection{Areas summation [1]} \label{sec:smt-areas-summation}
As \nameref{sec:areas-summation}, formulas were defined to assert that all the space inside the wrapping paper would be occupied. The first formula uses the sum of all \texttt{actual\_areas} and checks it to be equal to \texttt{area}, which in turn is equal to $w \cdot h$.

\begin{minted}[samepage]{python}
   Sum(actual_areas) == area
\end{minted}

The second formula is instead devoted to linking the computed area, i.e. the area obtained by \texttt{bl\_corners} and \texttt{tr\_corners}, of each present to its input one, i.e. the area obtained by \texttt{presents}.

\begin{minted}[samepage]{python}
   [actual_areas[i] == areas[i] for i in range(n)]
\end{minted}

After some testing, only the first formula made it into the final model, since the second one created more overhead than aid in the ease of computation.

\subsubsection{Positioning}
\begin{itemize}
   \item \nameref{sec:smt-count-eq}
\end{itemize}

\subsubsubsection{Translation of \texttt{count\_eq} [1]} \label{sec:smt-count-eq}
As \nameref{sec:present-at-origin}, we implemented a DNF (Disjunctive Normal Form) formula, in order to fix one present to have its bottom-left corner at the origin and to force another present's top-right corner to coincide with the bounding box one. 

\begin{minted}[samepage]{python}
   Or([
      And(bl_corners[i][0] == 0, bl_corners[i][1] == 0) 
      for i in range(n)
   ])
\end{minted}

\begin{minted}[samepage]{python}
   Or([
      And(tr_corners[i][0] == w_paper, tr_corners[i][1] == h_paper) 
      for i in range(n)
   ])
\end{minted}

\begin{figure}[H]
   \centering
   \begin{subfigure}[b]{0.4\textwidth}
      \centering
      \begin{tikzpicture}
         \draw[step=1cm,black,thin] (0,0) rectangle (3,3);
         \foreach \xtick in {0,...,3} {\pgfmathsetmacro\result{\xtick * 1} \node at (\xtick,-0.5) {\pgfmathprintnumber{\result}}; }
         \foreach \ytick in {0,...,3} {\pgfmathsetmacro\result{\ytick * 1} \node at (-.5,\ytick) {\pgfmathprintnumber{\result}}; }
         \draw[fill=cyan] (0,0) rectangle (2,1);
         \draw [fill=black, thin] (0,0) circle [radius=0.05];
      \end{tikzpicture}
      \caption{One present at the origin}
   \end{subfigure}
   \begin{subfigure}[b]{0.4\textwidth}
      \centering
      \begin{tikzpicture}
         \draw[step=1cm,black,thin] (0,0) rectangle (3,3);
         \foreach \xtick in {0,...,3} {\pgfmathsetmacro\result{\xtick * 1} \node at (\xtick,-0.5) {\pgfmathprintnumber{\result}}; }
         \foreach \ytick in {0,...,3} {\pgfmathsetmacro\result{\ytick * 1} \node at (-.5,\ytick) {\pgfmathprintnumber{\result}}; }
         \draw[fill=cyan] (2,1) rectangle (3,3);
         \draw [fill=black, thin] (3,3) circle [radius=0.05];
      \end{tikzpicture}
      \caption{One present at the top}
   \end{subfigure}
   \caption{Presents fixed positioning example}
\end{figure}

\subsubsection{Stacking}
\begin{itemize}
   \item \nameref{sec:smt-cumulative} $\rightarrow$ \xmark
\end{itemize}

\subsubsubsection{Translation of \texttt{cumulative} [1]} \label{sec:smt-cumulative}
In order to obtain "stacking" capabilities in our SMT model, we tried to translate MiniZinc's \texttt{cumulative} global constraint, taken from \cite{minizinc-lib}, as a list of formulas.

\begin{minted}[samepage]{python}
def z3_bool2int(v):
   '''
   Convert a boolean variable to an integer one
   '''
   return IntSort().cast(v)
\end{minted}

\begin{minted}[samepage]{python}
def z3_cumulative(s, d, r, b, ls, us):
   '''
   Return a list of constraints computing cumulative checks.
   Here, resources `r`, durations `d` and bound `b` 
   must be fixed
   '''
   c = []
   early = ls
   late = us + max(d)
   tasks = [i for i in range(len(s)) if r[i] > 0 and d[i] > 0]
   if late - early > 5000:
   for i in tasks:
      c1 = []
      for j in tasks:
         if j != i:
            c1.append(
               z3_bool2int(
                  And(s[j] <= s[i], s[i] < s[j] + d[j])
               ) * r[j]
            )
      c.append(b >= r[i] + Sum(c1))
   else:
      for t in range(early, late + 1):
         for i in tasks:
            c.append(
               Sum([(
                     If(s[i] <= t, 1, 0) * 
                     If(t < s[i] + d[i], 1, 0)
                  ) * r[i] 
                  for i in tasks
               ]) <= b
            )
   return c
\end{minted}

As in the second formula in \nameref{sec:smt-areas-summation}, the additional computational complexity of our \texttt{cumulative} translation didn't justify its introduction in the final model, as we were able to observe a drastic average slowdown in solving the given test instances.

\subsection{Models}
In this section are presented our final model and its solver strategy.

\subsubsection{Solver strategy}
First of all, we wanted to identify the type of sub-logic needed for our solver to efficiently prove satisfiability. The reason to have a (sub-)logic is pragmatic: to identify fragment of the main logic where it may possible to apply specialized and more efficient satisfiability techniques, as reported in \cite{smt-logics}.

The type of formulae that we are using for our final SMT model belong to the \textit{QF_LIA} family, where underscore-spaced words have the following meaning:
\begin{itemize}
   \item \textit{QF}: \textit{Quantifier Free} formula, i.e. a formula without the use of \textit{for all} and \textit{exists} quantifiers
   \item \textit{LIA}: \textit{Linear Integer Arithmetic} formula, i.e. the linear fragment of the \textit{Ints} theory
\end{itemize}

Following this identification, we tried to use this specific solver tactic (i.e. \textit{QF_LIA}), instead of the default one chosen by Z3 (i.e. \textit{smt}).

\begin{minted}[samepage]{python}
   SolverFor(logic="QF_LIA")
\end{minted}

Empirical tests showed that our model gets more efficiently processed by the standard solver, instead of the more specific one which we chose.

Another improvement that we wanted to bring was the usage of a parallel processing approach. In order to do that, a single Z3 flag had to be turned on:

\begin{minted}[samepage]{python}
   set_param('parallel.enable', True)
\end{minted}

The same empirical tests performed for the solver tactics showed no real benefit of enabling this kind of concurrency. 

So, our final model uses the default solver tactic (i.e. \textit{smt}) and a serial type of processing.

\subsubsection{Final model}
To present a global undestanding of our final SMT model, below we report a list linking to each and every included formula.

\begin{itemize}
   \item \nameref{sec:smt-diffn}
   \item \nameref{sec:smt-all-different}
   \item \nameref{sec:smt-reduce-presents-domains}
   \item \nameref{sec:smt-areas-summation}
   \item \nameref{sec:smt-count-eq}
\end{itemize}

Using this model we were able to solve every test instance in under $100$ seconds. Executing the model with a single instance seemed to provide answers much more rapidly w.r.t. solving the same instance along with the other ones. One example above all is the $39 \times 39$ instance, which when launched by itself resulted in a running time of around $50-60$ seconds, while when launched in a batch way, i.e. together with the other instances, didn't provide a valid solution in up to $300$ seconds.

\begin{figure}[H]
   \centering
   \includegraphics[scale=0.45]{smt-times.png}
   \caption{Final SMT model running times}
\end{figure}

\section{Conclusions}
This project work shows different implementations of various solutions to the presented \textit{PWP} problem. These solutions have been developed using both Constraint Programming methods, as described in \ref{sec:cp}, and Satisfiability Modulo Theory approaches, as reported in \ref{sec:smt}.

About CP, we were able to obtain great results using custom made predicates. The usage of global constraints helped improving performances in bigger instances of the problem, while our \nameref{sec:column-stacking} constraint enabled us to tackle specific scenarios in an effective and efficient way.

About optional parts of the project, they are included only in MiniZinc's models, and they are divided in "pieces rotation" and "presents with same dimension handling". 
Since pieces rotation vastly augments the search space, a generalization of the column stacking procedure could considerably boost our model's performance. Anyway, while it could be a valuable upgrade for future refinements, we decided to skip this part since it seemed too much time-consuming.

Comparing one CP model with its evolution shows a big difference in solving times, which are certainly due to the introduction of newer, more efficient constraints.

About SMT, we observed that only a small subset of ideas implemented in CP models were sufficient to already obtain good results with the Z3 library. Instead, adding new formulae quickly proved to be deteriorating for the overall running time measures.

Performance-wise, our final CP model is able to solve every test instance, except for the $23 \times 23$ one in under $1$ second, while our final SMT model has a running time upper-bound of around $100$ seconds, even though independent executions appear to have a high variability. 


\printbibliography

\end{document}
